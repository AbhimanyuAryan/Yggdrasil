#!/usr/bin/env julia

using SHA, BinaryProvider, BinaryBuilder
import BinaryBuilder: CompilerShard

function list_targz_files(d)
    files = try
        readdir(d)
    catch
        []
    end
    return [joinpath(d, f) for f in files if length(f) > 7 && f[end-6:end] == ".tar.gz"]
end


# Collect list of .tar.gz files
targz_files = list_targz_files(@__DIR__)
if isempty(targz_files)
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "Rootfs", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "BaseCompilerShard", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "GCCBootstrap", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "LLVMBootstrap", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "GCC", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "LLVM", "products")))
end

function teeln(io::IO, args...)
    println(io, args...)
    println(args...)
end

rht_path = joinpath(dirname(pathof(BinaryBuilder)), "RootfsHashTable.jl")
rht_mtime = stat(rht_path).mtime
if isfile(rht_path)
    shard_hash_table = include(rht_path)
else
    shard_hash_table = Dict{CompilerShard,String}()
end

# Read in all new shards, add them into shard_hash_table
for fname in targz_files
    # Skip any shard that was updated less recently than the hash table itself
    if stat(fname).mtime < rht_mtime
        continue
    end

    try
        name, version, platform = extract_name_version_platform_key(fname)

        # Split out target platform if we've got one.
        target = nothing
        if occursin("-", name)
            target = platform_key_abi(name[first(findfirst("-", name))+1:end])
            name = split(name, "-")[1]
        end

        tar_hash = open(fname, "r") do f
            bytes2hex(sha256(f))
        end
        # Open up the .squashfs file and ensure it's set to UID 0, for hashing purposes.
        sname = fname[1:end-7]*".squashfs"
        BinaryBuilder.rewrite_squashfs_uids(sname, 0)

        squash_hash = open(sname, "r") do f
            bytes2hex(sha256(f))
        end

        shard_hash_table[CompilerShard(name, version, platform, :targz; target=target)] = tar_hash
        shard_hash_table[CompilerShard(name, version, platform, :squashfs; target=target)] = squash_hash
    catch
        @warn("Failed on $(fname)")
    end
end


rm(rht_path*".new"; force=true)
open(rht_path*".new", "w") do fout
    teeln(fout, "## This file auto-generated by Yggdrasil/checksum.jl")
    teeln(fout, "shard_hash_table = Dict{CompilerShard,String}(")

    for (cs, hash) in shard_hash_table
        target = ""
        if cs.target != nothing
            target = "; target=$(repr(cs.target))"
        end
        teeln(fout, "    CompilerShard($(repr(cs.name)), $(repr(cs.version)), $(repr(cs.host)), $(repr(cs.archive_type))$(target))")
        teeln(fout, "      => $(repr(hash)),")
    end
    teeln(fout, ")")
end

mv(rht_path*".new", rht_path; force=true)
